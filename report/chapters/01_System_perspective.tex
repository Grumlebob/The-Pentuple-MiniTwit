\section{System's Perspective}
\label{ch:sys_persp} % used to ref this chapter

This section covers the main modules of the system with their  
respective technologies and dependencies, as well as how they
were deployed.

\subsection{Module view}

\begin{figure}[H]
    \centering
    \includesvg[width=\linewidth]{images/modules.drawio}
    \caption{Diagram showing the modules that make up the system with
    their dependencies and main technologies.}
    \label{fig:modules}
\end{figure}

Figure \ref{fig:modules} provides an overview of how the main modules are connected, specifically:
\begin{itemize}
    \item Users interact with the \texttt{Client} module
    \item The \texttt{Client} module sends requests to the \texttt{API} module which contains a \texttt{Postgres} database connection
    \item The \texttt{Monitor} module reads logs written by the \texttt{API}
    \item The \texttt{Integration tests} module uses services from the \texttt{API} and its own database instance to test the \texttt{API}
\end{itemize}

\subsection{Deployment view}

\begin{figure}[H]
      \centering
      \makebox[\linewidth]{
      \includesvg[width=1.4\textwidth]{images/deployment_diagram.drawio}}
      \caption{Deployment diagram showing how the modules were deployed.}
      \label{fig:deployment_diagram}
\end{figure}

We use \texttt{Digital Ocean} to deploy the respective modules to \texttt{droplets} running \texttt{Ubuntu 22.04} as illustrated in Figure \ref{fig:deployment_diagram}. It works by creating and pushing docker images which each droplet can pull and run.

\subsection{API}

The API functions as the backend for our MiniTwit application.
It is deployed as three separate units. 
It uses docker swarm with one leader/manager 
giving tasks to two workers. Thus, the leader functions as a 
load balancer using the workers as servers.
We decided that the leader should not be a worker,
because we wanted to function optimally as a load balancer.
We were not sure, how it would be affected by being another worker.
Instead we can use it to run other side tasks, like databse migrations.

The API project is implemented in \texttt{.NET} using \texttt{minimal API}\cite{minimalApi}.
The database communication is done using Entity Framework Core.
It logs using Serilog\cite{serilog}, 
which is configured to write to Seq\cite{seq}.

\subsection{Client}

The \texttt{Client} is the frontend for the MiniTwit application implemented as a \texttt{Blazor} webassembly app. This way the workload is distributed to the users' browsers rather than a server. It is responsible for sending requests and receiving response from the \texttt{API} module.

\subsection{Monitor}

Our \texttt{Monitor} uses the tool Seq\cite{seq}.
It handles logs and displays custom graphs based on 
the log information. We have both developer relevant 
graphs such as \texttt{API} response times and errors,
as well as business relevant graphs such as number 
of newly registered users and messages posted.
It is deployed on its own \texttt{Digital Ocean} droplet 
using an image provided by datalust\cite{seq}.

\subsection{Database}

The database is a PostgreSQL\cite{postgres} database.
It contains information about registered users,
posted messages, and followers.

\subsection{Sequence diagram}

\begin{figure}[H]
    \centering
    \makebox[\linewidth]{
    \includesvg[width=1.4\textwidth]{images/sequence_diagram.drawio}}
    \caption{Sequence diagram showing how the system acts upon 
    a user posting a message.}
    \label{fig:seq_diagram}
\end{figure}

In summary, users uses the Client to for instance post a message.
The Client sends a request to the API, which logs the request 
information, saves the message to the database, 
logs the reponse information and sends a response back to the 
Client. The Client then updates the UI for the user.
This is illustrated in Figure \ref{fig:seq_diagram}.
