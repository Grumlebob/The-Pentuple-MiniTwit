@page "/"
@page "/timeline"
@page "/timeline/{username}"
@using MiniTwit.Shared.DTO.Followers.FollowUser
@using MiniTwit.Client.Components
@inject MiniTwitClient MiniTwitClient
@inject NavigationManager NavManager

<h3>@PageTitle</h3>

<!-- For debugging: show current session username -->
<div>
    <p>User logged in: @Session.Username</p>
</div>

<!-- Display the posting form when logged in and not in a user timeline (or when viewing your own timeline) -->
@if (Session.IsLoggedIn && (Mode != TimelineMode.User || string.Equals(Session.Username, username, StringComparison.OrdinalIgnoreCase)))
{
    <div class="twitbox">
        <h3>What's on your mind, @Session.Username?</h3>
        <EditForm Model="newMessageModel" OnValidSubmit="PostMessage">
            <DataAnnotationsValidator/>
            <ValidationSummary/>
            <InputText @bind-Value="newMessageModel.TextContent" placeholder="Share something..." size="60"/>
            <button type="submit">Share</button>
        </EditForm>
    </div>
}

<!-- When viewing someone else's timeline, show the Follow/Unfollow button -->
@if (Mode == TimelineMode.User && Session.IsLoggedIn && !string.Equals(Session.Username, username, StringComparison.OrdinalIgnoreCase))
{
    <button @onclick="ToggleFollow">@FollowButtonText</button>
}

@if (_messages == null)
{
    <p>
        <em>Loading messages...</em>
    </p>
}
else if (!_messages.Any())
{
    <p>
        <em>There are no messages so far.</em>
    </p>
}
else
{
    <MessageFeed Messages="_messages"/>
}

@code {

    // Receive the session as a cascading parameter.
    [CascadingParameter] public UserSession Session { get; set; }

    // Optional route parameter: if present, we're showing a user timeline.
    [Parameter] public string username { get; set; }

    // Enum to track timeline modes.
    private enum TimelineMode
    {
        Private,
        Public,
        User
    }

    private TimelineMode Mode;

    // Holds the loaded messages.
    private IList<GetMessageResponse>? _messages;

    // Model for the new message posting form.
    private NewMessageModel newMessageModel = new();

    // Follow state for user timelines.
    private bool IsFollowing = false;

    // Dynamic page title based on mode.
    private string PageTitle => Mode switch
    {
        TimelineMode.Private => "My Timeline",
        TimelineMode.Public => "Public Timeline",
        TimelineMode.User => $"{username}'s Timeline",
        _ => "Timeline"
    };

    private string FollowButtonText => IsFollowing ? "Unfollow" : "Follow";

    protected override async Task OnParametersSetAsync()
    {
        // Determine timeline mode based on the route parameter and URL.
        if (!string.IsNullOrEmpty(username))
        {
            Mode = TimelineMode.User;
        }
        else
        {
            var relativePath = NavManager.ToBaseRelativePath(NavManager.Uri).TrimEnd('/');
            Mode = string.IsNullOrEmpty(relativePath) ? TimelineMode.Private : TimelineMode.Public;
        }

        // If in private mode and not logged in, redirect to the public timeline.
        if (Mode == TimelineMode.Private && !Session.IsLoggedIn)
        {
            NavManager.NavigateTo("/timeline", true);
            return;
        }

        // Load the appropriate messages.
        await LoadMessagesAsync();
    }

    private async Task LoadMessagesAsync()
    {
        switch (Mode)
        {
            case TimelineMode.User:
            {
                _messages = await MiniTwitClient.GetMessagesForUserAsync(username);
                // When viewing someone else's timeline, check follow status.
                if (Session.IsLoggedIn && !string.Equals(Session.Username, username, StringComparison.OrdinalIgnoreCase))
                {
                    var followersResponse = await MiniTwitClient.GetFollowersAsync(Session.Username);
                    IsFollowing = followersResponse.Followers.Any(f =>
                        string.Equals(f, username, StringComparison.OrdinalIgnoreCase));
                }

                break;
            }
            case TimelineMode.Private:
            {
                var publicMessages = await MiniTwitClient.GetMessagesAsync();
                var followersResponse = await MiniTwitClient.GetFollowersAsync(Session.Username);
                var followedUsernames = followersResponse.Followers.ToHashSet(StringComparer.OrdinalIgnoreCase);
                _messages = publicMessages.Where(m => followedUsernames.Contains(m.AuthorUsername)).ToList();
                break;
            }
            // Public timeline
            case TimelineMode.Public:
                _messages = await MiniTwitClient.GetMessagesAsync();
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    private async Task PostMessage()
    {
        var request = new PostMessageRequest(newMessageModel.TextContent);
        var response = await MiniTwitClient.PostMessageAsync(Session.Username, request);
        if (response.IsSuccessStatusCode)
        {
            await LoadMessagesAsync();
            newMessageModel.TextContent = string.Empty;
            StateHasChanged();
        }
        else
        {
            // Optionally handle the error.
        }
    }

    private async Task ToggleFollow()
    {
        if (IsFollowing)
        {
            var response = await MiniTwitClient.UnfollowUserAsync(Session.Username, new UnfollowRequest(username));
            if (response.IsSuccessStatusCode)
            {
                IsFollowing = false;
            }
        }
        else
        {
            var response = await MiniTwitClient.FollowUserAsync(Session.Username, new FollowRequest(username));
            if (response.IsSuccessStatusCode)
            {
                IsFollowing = true;
            }
        }

        StateHasChanged();
    }

    private class NewMessageModel
    {
        [Required(ErrorMessage = "Message cannot be empty")]
        public string TextContent { get; set; } = "";
    }

}